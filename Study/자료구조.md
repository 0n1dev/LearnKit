# 자료구조

## List와 구현체

### List

- 
    - 순서 고려, 중복 허용
    - Key가 중요하지 않음
    - 중복은 허용하고 순서대로 반복해서 작업하고 싶을 때 주로 사용

### ArrayList

- 
    - `Array`와 동일하게 Random Access가 가능
    - 특정 위치 탐색할 때 유용
    - 일정 크기를 넘어서 add가 이루어질 경우 크기를 늘림
    - 중간에 삽입, 삭제를 하는경우 `System.arraycopy`가 이루어지기 때문에 비효율적
    - 마지막을 기준으로 삽입, 삭제를 하는 경우 `LinkedList`보다 효율적

### LinkedList

- 
    - 처음 head부터 차례로 찾아나감
    - 비순차적인 데이터 추가, 삭제에 비효율성이라는 단점을 보완
    - element 개수가 가변적일 때 사용하는 것이 효율적
    - 새로운 데이터 추가 혹은 삭제할 때 데이터 복사 없이 작업이 이루어져 상당히 효율적

### 비교

- 
    - `ArrayList`는 정해진 크기에서 끝지점부터 순차적으로 add, remove 하는 경우 성능이 좋음
    - `ArrayList`는 Random Access가 가능하기에 특정 위치 탐색에 유리
    - `LinkedList`는 양 끝단에 삽입, 삭제가 자주 발생할 때 사용하면 좋음

## Map과 구현체

Key와 Value 쌍으로 하나의 데이터로 저장되는 형태

### HashMap

- 
    - Thread-safe 하지 않음 (ConcurrentHashMap을 사용하면 됨)
    - Key에 Null값 사용 가능
    - 보조 해시 함수를 사용하기 때문에 해시 충돌이 덜 발생할수 있어 성능상 이점이 있음

### HashTable

- 
    - Thread-safe 함
    - Key에 Null 사용 불가능

### Hashing

하나의 문자열을 원래의 것을 상징하는 더 짧은 길이의 값이나 키로 변환하는 것

Hash Table과 Hash Function으로 구성

### HashFunction

데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수

### Hash Collision

동일 Key 값에 복수 개의 데이터가 하나의 테이블에 존재하는 경우

- Open Address 방식
    - 해시 충돌이 발생하면, `다른 해시 버킷에 해당 자료를 삽입`하는 방식
    - 체이닝 처럼 추가적인 저장공간이 필요없다.
    - 선형 탐색 - 순차적으로 탐색하여 비어있는 버킷을 찾을 때까지 진행
    - 제곱 탐색 - 해시 충돌 시 제곱만큼 건너뛴 버킷에 데이터 삽입
    - 이중 해시 - 해시 충돌 발생 시 다른 해시함수를 한번 더 사용하여 결과를 이용
- Separate Chaining 방식
    - 해시 충돌이 발생하면, `버킷 내에 연결리스트 혹은 트리를 활용하여 데이터들을 연결하는 방식`입니다.
    - 복잡한 계산식 사용이 필요 없다.