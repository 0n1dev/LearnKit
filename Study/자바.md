# 자바

## 클래스 로딩 절차

1. 주어진 클래스의 이름으로, 클래스 Path에 존재하는 바이너리로 된 자바 클래스를 찾습니다.
2. 자바 클래스를 정의합니다.
3. 해당 클래스를 나타내는 Java.lang 패키지의 Class 클래스의 객체를 생성합니다.
4. 링크 작업이 수행됩니다. 이 단계에서 static 필드를 생성 및 초기화하고, 메소드 테이블을 할당합니다.
5. 클래스의 초기화가 진행되며, 클래스의 static 블럭과 static 필드가 가장 먼저 초기화 됩니다.

loading → linking → Initializing

## Byte Code로 컴파일 하는 이유

CPU와 OS에 독립적, JVM만 있으면 실행 가능

단, 느림 (기계어 코드를 직접 읽어 실행하는게 가장 빠름)

## JIT 컴파일 (Just In time)

- 바이트 코드를 실행하기 직전 기계어 코드로 컴파일 하는 방식
    - 바이트 코드를 해석해서 실행하는 것(인터프리터 방식)보다 기계어 코드로 변환해서 실행하는 것이 훨씬 더 빠름
- JVM 내부에 내장되어있음

## Garbage Collection

- Java에서 new 연산자를 사용하여 생성된 객체가 자동으로 제거되는 것을 의미합니다.
- 어떤 객체를 참조하는 변수가 하나라도 있으면, 그 객체는 사용되는거고 반대로 참조하는 변수가 없다면, 그 객체는 GC됩니다.

### Stop-the-world

- GC가 실행될 때, 그 JVM에서 애플리케이션은 모두 정지되고, 오로지 GC 작업만 실행됩니다.
- 성능이 매우 중요한 애플리케이션의 경우, GC가 실행되는 동안 애플리케이션이 정지되는 것이 문제가 될 수 있습니다.

### 변수에 NULL 대입

- 더 이상 객체를 사용하지 않을 때, 그 객체를 참조하는 변수에 null을 대입하는 것이 좋습니다.

## GC의 종류

- Serial Garbage Collector
    - CPU 코어의 수가 1개일 때 사용
    - Minor GC, Major GC 모두 싱글 스레드로 실행
- Parallel Garbage Collector
    - Young 영역의 GC를 `멀티 스레드`로 실행
    - CPU 코어가 여러개인 경우 parallel GC가 디폴트로 설정되고, 코어 수 만큼 스레드로 GC를 수행
- CMS Garbage Collector
    - GC 작업 동안의 정지 기간을 최대한 줄이기 위한 선택
    - Heap의 크기가 4GB 이하인 경우 사용합니다.
    - compact 작업을 포함하지 않기 때문에 메모리 공간도 낭비
- G1 Garbage Collector
    - Java 7 부터 제공
    - 크기가 4GB 이상인 Heap에 대해 효율적인 GC를 위해 개발되었습니다.
    - compact 작업을 포함하고 있습니다.

### GC 과정

Heap에는 Young 영역과 Old 영역이 나눠져 있는데

처음 객체가 생성되면 Young 영역에 있는 Eden에  추가됩니다.

Eden영역에 가득차면 서바이벌 영역으로 넘어가고 서바이벌 영역은 1과 2가있는데 한쪽이 가득차면 다른 한쪽으로 이동합니다.

이동할때 mark and sweep이 발생하는데 변수가 참조하지 않는 객체는 사라지고 살아있는 객체는 age가 올라갑니다.

계속 반복하다 age가 어느 한계점까지 올라가면 old 영역으로 넘어갑니다. 이걸 promotion이라합니다.

old 영역에서 가득차면 Major GC가 발생합니다.

## Java에서 Collection이란?

다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합입니다.
종류로는 List, Map, Set과 Stack, Queue가 있습니다.

### 배열과 다른점

- 객체를 보관하기 위한 공간을 미리 정하지 않아도 됩니다.
- 상황에 따라 객체의 수를 동적으로 정할수 있습니다.

## Annotation이란?

주석이란 뜻으로, 인터페이스를 기반으로 한 문법입니다.

주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나, 기능을 주입할 수 있습니다.

## Generic

다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능입니다.

객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.

## 람다식이란?

자바8에 도입된 문법으로 익명 함수를 생성하기 위한 식입니다. 객체지향 보다는 함수 지향에 가깝습니다.

### 장점

- 필요한 정보만을 사용하는 방식을 통한 성능이 향상됨
- 코드가 간결해져 개발자의 의도가 명확히 드러나므로 가독성 향상

### 단점

- 이론상 단순하게 모든 원소를 전부 순회하는 경우 람다식이 조금 느릴 수 있음
- 디버깅 시 함수 콜 스택 추적이 다소 어려움
- 람다를 사용하여 만든 무명함수는 재사용이 불가능함

## Optional이란?

자바8에 도입된 문법으로 NullPointerException을 방지할수 있도록 합니다.

NullPointerException을 제공되는 메서드를 통해 간단히 회피할 수 있어 복잡한 조건문이 없어도 예외 처리가 가능합니다.

## Stream API란?

자바8에 도입된 문법으로 손쉽게 데이터 파이프라인을 구성할수있도록 제공되는 API입니다.

- 일회용
- 손쉬운 병렬 처리
    - parallel() 메서드를 스트림에서 호출해주면 됩니다.

스트림 생성 → 중간 연산 → 최종 연산