# 릴레이션의 직교성

> 정규화만큼 중요하지만 간과하기 쉬운 것 **릴레이션의 직교성**

- 여러 릴레이션 사이의 중복에 관한 개념
- DB 전체에서 중복을 제거하는 작업

## 릴레이션의 직교성과 중복

> 같은 값을 가진 릴레이션은 어떤 것인지? 어떻게 해결하면 좋을지 알아보자

### 레플리카

- 완전히 같은 구조와 같은 데이터를 가진 릴레이션이 여러개 있는 경우
- 현실적으로 이와 같은 설계를 가진 DB와 접할 일은 없을 것이다.
- 비슷한 기능을 가진 릴레이션이 있을 때나 통합 후에 같은 기능을 가진 릴레이션이 생기는 경우를 생각할 수 있다.

### 같은 형태의 릴레이션

- 주문 데이터를 기록하는 릴레이션에 2000~2014년의 데이터를 1년마다 다른 릴레이션에 저장하는 경우 같은 형태일것이다.
- 중복된 튜플이 없으므로 두 개의 릴레이션은 직교한다고 할 수 있다.
 
### 제목 일부만 같은 릴레이션

- 제목이 완전히 같지는 않지만 일부가 공통일 때
- 튜플 전체가 같은 값이 아니어도 직교가 아니라 할 수 있는가?
- 6NF가 될 때까지 무손실 분해하고 튜플을 비교해 중복이 없는 것을 확인하면 직교성을 보잔할 수 있음

## 릴레이션 직교화를 위한 전략

> 릴레이션의 직교성을 이해한 시점에서 어떻게 직교성을 보장하는지 알아보자

### 정규화

- 6NF까지 정규화를 하면 됨
- 5NF로 졍규화되어 있으면 6NF는 키가 아닌 속성만을 대상으로 무손실 분해
- 정규화를 제대로 해두면 릴레이션 그자체를 다루기 쉬울 뿐만 아니라 직교성을 확인할 때도 도움 됨

### 속성의 이름 통일

- 직교화를 하고 있는지 아닌지 확인을 하려면 다른 릴레이션에 있는 속성이 같은 것을 의미하는지 확인이 필요
- 이름이 다르면 알기 어려움

#### 명명규칙 통일하기

- 영어 or 로마자
- 캐멀 케이스 or 스네이크 케이스
- 일괄적으로 정의

#### 주어를 포함

- student_name, sns_user_email와 같이 구체적인 의미를 포함한 이름으로 해야 함

### 응용프로그램의 정합성

- 다른 두 가지의 기능에 같은 의미의 데이터가 필요할 때 공통의 구성 요소를 설계하는 대신 독립된 DB에 데이터를 등록하면 직교하지 않는 DB가 완성
- 규모가 커지고 기능이 늘어날수록 직교하지 않을 가능성이 높아짐

#### 전체를 직교화할 필요는 없다

- 반드시 모든 릴레이션을 직교화할 필요는 없다.

## 중복을 해결해 얻는 이점

### 변칙을 막을 수 있다.

- 중복을 방지함으로써 가장 큰 장점은 **중복**을 막을 수 있다.

### 필요한 데이터가 어디에 있는지 명확해진다.

- 중복이 해결되면 한 개의 튜플이 나타내는 사실은 다른 어떤 튜플에도 존재하지 않는다.
- 중복이 없다면 참조, 갱신 어떤 경우도 헤매지 않고 쿼리를 작성할 수 있다.

### 불필요한 무손실 분해는 필요 없다.

- 릴레이션이 정규화되어 있지 않다는 것은 어떤 두 개 이상의 릴레이션을 결합한 결과가 그 릴레이션이 된다는 의미다.

### 복잡한 제약은 필요 없다.

- 정규화와 직교화가 완료되지 않은 경우 갱신하더라도 변칙이 생기지 않게 하려면 제약을 걸어야 한다.

### 응용프로그램의 코드에 낭비가 없어진다.

- 변칙을 확인하기 위한 로직뿐만 아니라 변칙이 발생했을 때 어떻게 해야 할지도 생각하지 않으면 안되기 때문

### 성능이 향상된다.

- 중복이 있으면 DB의 부담은 비약적으로 상승한다.